// File:    Board.cpp
// Purpose: Implementation file for the Board class.

#include <iostream> // library for reading & writing from the console/keyboard
#include "Board.h" // allows access to the header file

//Constructed from
Board::Board(std::string a_p1_token, std::string a_p2_token, std::string a_blank_token) {
    p1_token=a_p1_token;
    p2_token=a_p2_token;
    blank_token=a_blank_token;
    total_rows=5;
    total_cols=4;
    m_data=new std::string* [total_cols]; 
    col_data=new int [total_cols];
    for (int i = 0; i < total_cols; i++) {
        m_data[i] = NULL;
        col_data[i]=0;
    }
}
//Destructor
Board::~Board() {
    delete [] m_data;
}

// ACCESSORS
int Board::numRows() const {
    return total_rows; 
}

int Board::numColumns() const {
    return total_cols;
}

std::string Board::getBlankToken() const {
    return blank_token;
}

std::string Board::getP1Token() const {
    return p1_token;
}

std::string Board::getP2Token() const {
    return p2_token;
}

int Board::numTokensInRow(int row) const { //DONE
    if (0<=row && row<total_rows) {
        int tokens_in_row=0;
        for (int i=0; i<total_cols; i++) {
            if ((*this).numTokensInColumn(i)>0 && (*this).numTokensInColumn(i)>=row-1) {
                tokens_in_row=tokens_in_row+1;
            }
        }
        return tokens_in_row;
    }
    else {
        return -1;
    }
}

int Board::numTokensInColumn(int col) const { //DONE
    if (0<=col && col<total_cols) {
        return col_data[col];
    }
    else {
        return -1;
    }
}

std::string** Board::getBoard() const{
    return m_data;
}

std::string Board::insert(int col, bool player) {
    //determining player
    std::string token;
    if (player==true) {//player 1
        token=p1_token;
    }
    else if (player==false) { //player 2
        token=p2_token;
    }
    //adding tokens
    if (col<total_cols) { //adds token to a currently existing column
        if (m_data[col]==NULL) { //if null
            std::cout << " HELLO " <<std::endl;
            m_data[col] = new std::string[1]; //creates an array for the col
            m_data[col][0]=token;
            col_data[col]=1;
        }
        else if (m_data[col]!=NULL) {
            std::cout << " HELLO2 " << std::endl;
            if ( ((*this).numTokensInColumn(col)+1)>total_rows) {
                total_rows=total_rows+1;
            }
            std::string* temp = new std::string[(*this).numTokensInColumn(col)+1];
            for (int i; i<(*this).numTokensInColumn(col); i++) { //copies contents to temp
                temp[i]=m_data[col][i];
            }
            temp[(*this).numTokensInColumn(col)]=token;//adds new token
            delete [] m_data[col]; //removes old col
            m_data[col] = temp;
            col_data[col]=col_data[col]+1;
        }
    }
    else if (col>=total_cols) { //adds a column to the right
        std::cout << " HELLO3 " << std::endl;
        std::string** temp = new std::string* [total_cols+1];
        int* temp_col_data=new int [total_cols+1];
        for (int i; i<total_cols; i++) { //copies contents to temp
            temp[i]=m_data[i];
            temp_col_data[i]=col_data[i];
        }
        temp[total_cols] = new std::string[1]; //creates an array for the col
        temp[total_cols][0]=token; //adds new token
        delete [] m_data; //removes old board
        m_data=temp;
        temp_col_data[total_cols]=1;
        delete [] col_data;
        col_data=temp_col_data;
        
        total_cols=total_cols+1;
    }
    //if no one wins return the blank token, and if someone does win return their token
    //win conditions
    /*for (int i; i<total_cols; i++) { 
        for (int i; i<total_cols; i++) { 
            int x;
        }   
    }*/
}

void Board::clear() {
    for (int i = 0; i < 4; i++) {
        delete [] m_data[i]; //removes old col
        m_data[i] = NULL;
        col_data[i]=0;
    }
    total_rows=5;
    total_cols=4;
}

// The output stream operator takes two arguments: the stream (e.g., cout) and the object
// to print.  It returns a reference to the output stream to allow a chain of output.
std::ostream& operator<< (std::ostream& ostr, const Board& b) {
    std::string board_string;
    for (int i=b.numRows()-1; i>=0; i--) { //rows
        for (int j = 0; j < b.numColumns(); j++) { //cols
            if (b.getBoard()[j]==NULL ) {
                board_string=board_string+b.getBlankToken();
            }
            else {
                std::cout << "column " << j << " and row " << i <<std::endl;
                std::cout <<board_string<<std::endl;
                if (b.getBoard()[j][i]!=b.getP1Token() && b.getBoard()[j][i]!=b.getP2Token()) {
                    board_string=board_string+b.getBlankToken();
                }
                else {
                    std::cout << "hi " <<std::endl;
                    //std::cout <<b.getBoard()[j][i]<<std::endl;
                    board_string=board_string+b.getBoard()[j][i];
                }
            }
            if (j<(b.numColumns()-1) ) { //not yet end of row
                board_string=board_string+" ";
            }
            else {//end of row
                board_string=board_string+"\n";
            }
        }
    }
    ostr << board_string;
    return ostr;
}